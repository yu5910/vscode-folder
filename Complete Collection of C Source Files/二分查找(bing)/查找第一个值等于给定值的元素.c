// 二分查找函数，参数为有序数组arr，数组长度len，目标元素target
// 返回值为目标元素在数组中的索引，如果不存在则返回-1
int binary_search(int arr[], int len, int target)
{
    // 定义左右边界指针
    int left = 0;
    int right = len - 1;
    // 循环条件为左右边界不相交
    while (left <= right)
    {
        // 计算中间元素的索引
        int mid = left + ((right - left) >> 1);
        // 如果中间元素大于等于目标元素，舍弃右半部分数组，将右边界移动到中间元素的左边
        if (arr[mid] >= target)
        {
            right = mid - 1;
        }
        // 如果中间元素小于目标元素，舍弃左半部分数组，将左边界移动到中间元素的右边
        else
        {
            left = mid + 1;
        }
    }
    // 如果循环结束后，左边界没有越界，并且左边界对应的元素等于目标元素，返回索引
    if (left < len && arr[left] == target)
    {
        return left;
    }
    // 否则返回-1
    else
    {
        return -1;
    }
}
你想要我把这段代码改编成 C 语言吗？这段代码是用 Java 语言实现的二分查找算法的一个变体，它的目的是在一个有序的数组中，查找第一个值等于给定值的元素的位置。我可以尝试用 C 语言来写一个类似的代码，但是你要知道，不同的编程语言有不同的语法和风格，所以我的代码可能不是最优或最标准的。你可以参考一下我的代码，但是也要自己学习和练习，才能掌握 C 语言。😊

我用 C 语言改编的代码如下：

```c
// 二分查找函数，参数为有序数组arr，数组长度len，目标元素target
// 返回值为目标元素在数组中的索引，如果不存在则返回-1
int binary_search(int arr[], int len, int target) {
  // 定义左右边界指针
  int left = 0;
  int right = len - 1;
  // 循环条件为左右边界不相交
  while (left <= right) {
    // 计算中间元素的索引
    int mid = left + ((right - left) >> 1);
    // 如果中间元素等于目标元素，判断是否是第一个
    if (arr[mid] == target) {
      // 如果是第一个或者前一个元素不等于目标元素，返回索引
      if (mid == 0 || arr[mid - 1] != target) {
        return mid;
      }
      // 否则舍弃右半部分数组，将右边界移动到中间元素的左边
      else {
        right = mid - 1;
      }
    }
    // 如果中间元素小于目标元素，舍弃左半部分数组，将左边界移动到中间元素的右边
    else if (arr[mid] < target) {
      left = mid + 1;
    }
    // 如果中间元素大于目标元素，舍弃右半部分数组，将右边界移动到中间元素的左边
    else {
      right = mid - 1;
    }
  }
  // 如果循环结束还没有找到目标元素，返回-1
  return -1;
}
```

    希望这个代码对你有帮助。😊

    : [二分查找]

      你想要我把这段代码改编成 C 语言吗？这段代码是用 Java 语言实现的二分查找算法的一个变体，它的目的是在一个有序的数组中，查找第一个值等于给定值的元素的位置。我可以尝试用 C 语言来写一个类似的代码，但是你要知道，不同的编程语言有不同的语法和风格，所以我的代码可能不是最优或最标准的。你可以参考一下我的代码，但是也要自己学习和练习，才能掌握 C 语言。😊

          我用 C 语言改编的代码如下：






```c
      // 二分查找函数，参数为有序数组arr，数组长度len，目标元素target
      // 返回值为目标元素在数组中的索引，如果不存在则返回-1
      int
      binary_search(int arr[], int len, int target)
{
  // 定义左右边界指针
  int left = 0;
  int right = len - 1;
  // 循环条件为左右边界不相交
  while (left <= right)
  {
    // 计算中间元素的索引
    int mid = left + ((right - left) >> 1);
    // 如果中间元素等于目标元素，判断是否是第一个
    if (arr[mid] == target)
    {
      // 如果是第一个或者前一个元素不等于目标元素，返回索引
      if (mid == 0 || arr[mid - 1] != target)
      {
        return mid;
      }
      // 否则舍弃右半部分数组，将右边界移动到中间元素的左边
      else
      {
        right = mid - 1;
      }
    }
    // 如果中间元素小于目标元素，舍弃左半部分数组，将左边界移动到中间元素的右边
    else if (arr[mid] < target)
    {
      left = mid + 1;
    }
    // 如果中间元素大于目标元素，舍弃右半部分数组，将右边界移动到中间元素的左边
    else
    {
      right = mid - 1;
    }
  }
  // 如果循环结束还没有找到目标元素，返回-1
  return -1;
}
```

    希望这个代码对你有帮助。😊

    : [二分查找]